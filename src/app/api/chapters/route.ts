import { NextRequest, NextResponse } from "next/server";
import fs from "fs/promises";
import path from "path";

const ALBUMS_FILE = path.join(process.cwd(), "public", "photos", "albums.json");

interface Chapter {
  id: string;
  title: string;
  narrative?: string;
  photoIds: string[];
}

interface AlbumManifest {
  lastUpdated: string;
  albums: any[];
  photos: any[];
  chapters: Record<string, Chapter[]>;
}

async function loadManifest(): Promise<AlbumManifest> {
  const data = await fs.readFile(ALBUMS_FILE, "utf-8");
  return JSON.parse(data);
}

async function saveManifest(manifest: AlbumManifest): Promise<void> {
  manifest.lastUpdated = new Date().toISOString();
  await fs.writeFile(ALBUMS_FILE, JSON.stringify(manifest, null, 2));

  // Also regenerate the TypeScript data file
  await regenerateDataFile(manifest);
}

async function regenerateDataFile(manifest: AlbumManifest): Promise<void> {
  const dataPath = path.join(process.cwd(), "src", "lib", "synced-data.ts");

  const content = `// Auto-generated by sync service - DO NOT EDIT
// Last updated: ${manifest.lastUpdated}

import type { Album, Photo, Chapter } from "./types";

export const albums: Album[] = ${JSON.stringify(
    manifest.albums.map((a: any) => ({
      id: a.id,
      slug: a.slug,
      title: a.title,
      subtitle: a.subtitle,
      description: a.description,
      location: a.location,
      date: a.date,
      coverImage: a.coverImage,
      photoCount: a.photoCount,
      featured: a.featured,
    })),
    null,
    2
  )};

export const photos: Photo[] = ${JSON.stringify(
    manifest.photos.map((p: any) => ({
      id: p.id,
      title: p.title,
      description: p.description,
      src: p.src,
      metadata: p.metadata,
      albumId: p.albumId,
    })),
    null,
    2
  )};

export const chapters: Record<string, Chapter[]> = ${JSON.stringify(
    Object.fromEntries(
      Object.entries(manifest.chapters || {}).map(([albumId, chaps]) => [
        albumId,
        (chaps as Chapter[]).map((c) => ({
          id: c.id,
          title: c.title,
          narrative: c.narrative,
          photos: manifest.photos.filter((p: any) => c.photoIds.includes(p.id)),
        })),
      ])
    ),
    null,
    2
  )};

// Helper functions
export function getAlbums(): Album[] {
  return albums;
}

export function getAlbumBySlug(slug: string): Album | undefined {
  return albums.find((a) => a.slug === slug);
}

export function getPhotosByAlbum(albumId: string): Photo[] {
  return photos.filter((p) => p.albumId === albumId);
}

export function getPhotoById(id: string): Photo | undefined {
  return photos.find((p) => p.id === id);
}

export function getChaptersByAlbum(albumSlug: string): Chapter[] {
  const album = albums.find((a) => a.slug === albumSlug);
  if (!album) return [];
  return chapters[album.id] || [];
}

export function getFeaturedAlbum(): Album | undefined {
  return albums.find((a) => a.featured) || albums[0];
}
`;

  await fs.writeFile(dataPath, content, "utf-8");
}

// GET - Get chapters for an album
export async function GET(request: NextRequest) {
  const albumId = request.nextUrl.searchParams.get("albumId");

  if (!albumId) {
    return NextResponse.json({ error: "albumId required" }, { status: 400 });
  }

  try {
    const manifest = await loadManifest();
    const chapters = manifest.chapters?.[albumId] || [];
    const photos = manifest.photos.filter((p: any) => p.albumId === albumId);

    return NextResponse.json({ chapters, photos });
  } catch (error) {
    return NextResponse.json({ error: "Failed to load chapters" }, { status: 500 });
  }
}

// POST - Create or update chapters for an album
export async function POST(request: NextRequest) {
  try {
    const { albumId, chapters } = await request.json();

    if (!albumId || !chapters) {
      return NextResponse.json({ error: "albumId and chapters required" }, { status: 400 });
    }

    const manifest = await loadManifest();

    if (!manifest.chapters) {
      manifest.chapters = {};
    }

    manifest.chapters[albumId] = chapters;
    await saveManifest(manifest);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error saving chapters:", error);
    return NextResponse.json({ error: "Failed to save chapters" }, { status: 500 });
  }
}

// DELETE - Remove all chapters for an album
export async function DELETE(request: NextRequest) {
  try {
    const { albumId } = await request.json();

    if (!albumId) {
      return NextResponse.json({ error: "albumId required" }, { status: 400 });
    }

    const manifest = await loadManifest();

    if (manifest.chapters?.[albumId]) {
      delete manifest.chapters[albumId];
      await saveManifest(manifest);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: "Failed to delete chapters" }, { status: 500 });
  }
}
